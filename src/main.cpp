#include "Arduino.h"

#include <SD.h>
#include <Adafruit_GFX.h>    // Core graphics library
#include <Adafruit_ST7735.h> // Hardware-specific library for ST7735
#include <Adafruit_NeoPixel.h> // LED Ring library
#include <Ticker.h>
#include <Wire.h>
#include <SPI.h>


#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <ESP8266WebServer.h>
#include <AutoConnect.h>
#include <CertStoreBearSSL.h>
#include <time.h>
#include <FS.h>

// LED Ring pin and count
#define LED_PIN D1
#define LED_COUNT 12

// Screen dimensions and pin assignments
#define HEIGHT 128
#define WIDTH 160
#define LID D0
#define BACKLIGHT D2
#define TFT_CS         D8
#define TFT_RST        D4
#define TFT_DC         D3
Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

#undef AUTOCONNECT_URI
#define AUTOCONNECT_URI         "/_ac/config"

// Debug mode, prints messages to the Serial port
#define DEBUG 1

// Neopixel ring instance
Adafruit_NeoPixel ring(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);

// WiFi specific variables
ESP8266WebServer Server;
BearSSL::WiFiClientSecure *bearSSL;
BearSSL::CertStore certStore;
HTTPClient client;
AutoConnect Portal(Server);
AutoConnectConfig PortalConfig;
boolean serverAvailable = true;
boolean wifiConnected = false;
String host = "messagebox.unitfi.com";
const char * headerKeys[] = {"user", "code", "Content-Type", "status"};
const size_t numberOfHeaders = 4;

// Name of file to save image to
String imageName = "/message.tft";

// Unique 32-byte key generated by box for authentication
String key;

// User ID from server for retrieving message. Presence of user indicates
// we've registered with the server
String user;

// One-time activation code used to register the box
String code;

// Indicates if we've already completed some action for the lid opening, preventing
// multiple screen writes, clearing messages right away, etc
boolean state = false;

// Interrupt and corresponding variables for rate-limiting
Ticker timer;
volatile int httpCheck = 0;
volatile int lidCheck = 0;
volatile int ledCheck = 0;

// Function declarations
void onTime();
void setClock();
void downloadMessage();
void displayWiFiLogin();
void displayConnecting();
void displayWiFiConnected();
void displayActivationCode();
void displayNoServer();
void displayMessage();
void drawHeart(int, int);


void resetBox() {
  SPIFFS.remove("/key.txt");
  SPIFFS.remove("/user.txt");
  ESP.restart();
}

void setup(void)
{
  if(DEBUG){
    Serial.begin(9600);
    Serial.println("Starting messagebox");
  }

  // Start LED Ring, assigning random colors to each LED during setup
  ring.begin();
  uint32_t color = ring.Color(15, 15, 255);
  for(int i=0; i<ring.numPixels(); i++){
    color = ring.Color(random(255), random(255), random(255));
    ring.setPixelColor(i,color);
  }
  ring.setBrightness(16);
  ring.show();

  //Intitialize the lcd screen, and show "splash screen"
  pinMode(BACKLIGHT, OUTPUT);
  pinMode(LID, INPUT);
  tft.initR(INITR_BLACKTAB);
  tft.setRotation(1);
  tft.fillScreen(ST77XX_BLACK);
  tft.setTextColor(0xFFFF);
  tft.setCursor(50, 60);
  tft.print("MessageBox");
  digitalWrite(BACKLIGHT, HIGH);
  delay(3000);

  // Initialize timer for lcd and http
  timer1_attachInterrupt(onTime);
  timer1_enable(TIM_DIV256, TIM_EDGE, TIM_LOOP); // 80MHz Base / 256 = 312.5KHz -> 3.2us
  timer1_write(3125);  // 3.2us * 3125 ~= 10000us -> 10ms

  // Inform the user we're attempting to connect to WiFi
  displayConnecting();

  // Start the wifi autoconnect service
  PortalConfig.apid = "Messagebox";
  PortalConfig.bootUri = AC_ONBOOTURI_HOME;
  PortalConfig.homeUri = "/_ac/config";
  PortalConfig.psk = "";
  PortalConfig.portalTimeout = 1;
  PortalConfig.retainPortal = true;
  Portal.config(PortalConfig);
  Portal.begin();

  // Wait for the box to be connected to WiFi, informing user of how to log in
  displayWiFiLogin();
  while(WiFi.status() != WL_CONNECTED){
    Portal.handleClient();
    delay(100);
  }

  // Bring down the Access Point
  if(DEBUG){Serial.println("Successfully connected to WiFi");}
  WiFi.softAPdisconnect(true);
  displayWiFiConnected();

  // Prepare clock and SSL Certificates
  if(DEBUG){Serial.println("Preparing SSL");}
  setClock();

  // Clear the screen and draw a heart
  tft.fillScreen(ST77XX_BLACK);
  drawHeart((160 / 2) - 8, (128/2) - 8);

  // Start filesystem for Authentication credentials and SSL Certs
  SPIFFS.begin();

  int numCerts = certStore.initCertStore(SPIFFS, PSTR("/certs.idx"), PSTR("/certs.ar"));
  if(DEBUG){Serial.printf("Certs read: %d\n", numCerts);}

  if(numCerts == 0) {
    if(DEBUG){Serial.println("Missing certs!");}
    // TODO: Inform the user with what has actually gone wrong. This usually
    // happens when certs have not been loaded into the filesystem
    return;
  }

  bearSSL = new BearSSL::WiFiClientSecure();
  bearSSL->setCertStore(&certStore);


  // Check if a generated key exists. If it does not exist,
  // Create a new one (randomly generated 32-byte key)
  if (SPIFFS.exists("/key.txt"))
  {
    File keyFile = SPIFFS.open("/key.txt", "r");
    key = keyFile.readString();
    keyFile.close();
  } else {
    key = "";
    for( int i = 0; i < 32; i++)
    {
      key += String(random(255), HEX);
    }
    File keyFile = SPIFFS.open("/key.txt", "w");
    keyFile.print(key);
    keyFile.close();
  }

  // Check if we have a User ID saved. Presence of User ID
  // indicates we've successfully been registered.
  if (SPIFFS.exists("/user.txt"))
  {
    File userFile = SPIFFS.open("/user.txt", "r");
    user = userFile.readString();
  }
  else
  {
    user = "";
  }
}

void loop(void)
{
  // Run screen and LED Ring functions
  if(lidCheck >= 5){
    lidCheck = 0;
    if(digitalRead(LID) == LOW){
      ring.setBrightness(0);
      ring.show();
      // If we haven't already completed some action for this instance of the lid being removed,
      // Try to display a message first. If there is no message, show any other issues, otherwise
      // Show a heart to indicate the box is active but there is nothing to do.
      if(!state){
        if(SPIFFS.exists(imageName)){
          if(DEBUG){Serial.println("Displaying Message.");}
          displayMessage();
          SPIFFS.remove(imageName);
          ring.setBrightness(0);
          ring.show();
        } else if(user == "" && code != "") {
          displayActivationCode();
          if(DEBUG){Serial.println("Unit not activated. Displaying activation code.");}
        } else if(!serverAvailable){
          displayNoServer();
          if(DEBUG){Serial.println("Server not available.");}
        } else {
          tft.fillScreen(ST77XX_BLACK);
          drawHeart((160 / 2) - 8, (128/2) - 8);
          if(DEBUG){Serial.println("Nothing to display.");}
        }
      }
      state = true;
      digitalWrite(BACKLIGHT, HIGH);
    } else {
      // Lid is on, turn the backlight off
      digitalWrite(BACKLIGHT, LOW);
      state = false;
    }
  }

  if(httpCheck >= 1000){
    httpCheck = 0;
    if(SPIFFS.exists(imageName)){
      //We have a message waiting to be read. Do nothing.
      //httpCheck = 0;
    } else if(user != "") {
      // Begin asking the server if we have any new messages
      client.begin(*bearSSL, String("https://" + host + "/message/read") +
                      "?key=" + key +
                      "&user=" + user);
      client.collectHeaders(headerKeys, numberOfHeaders);
      int httpCode = client.GET();

      if(httpCode >= 200 && httpCode <= 299){
        serverAvailable = true;
        if(DEBUG){Serial.println("Successfully contacted server");}
      } else {
        serverAvailable = false;
        if(DEBUG){Serial.println("Server contact failure: " + String(httpCode));}
      }

      // Check status and react accordingly
      if(client.hasHeader("status")){
        String status = client.header("status");
        if(status == "No Messages"){
          //No message, do nothing.
          if(DEBUG){Serial.println("No Messages.");}
        } else if(status == "New Message" && client.header("Content-Type") == "application/octet-stream"){
          downloadMessage();
          uint32_t color = ring.Color(15, 15, 255);
          for(int i=0; i<ring.numPixels(); i++){
            ring.setPixelColor(i,color);
          }
          ring.setBrightness(64);
          ring.show();
        } else if(status == "No Box"){
          if(DEBUG){Serial.println("Resetting box");}
          resetBox();
        } else if(status == "Update"){
          if(DEBUG){Serial.println("System update");}
          //Update system
        }
      }
      client.end();
    } else {
      // We haven't authenticated yet, send credentials to server until
      // we get a user id
      client.begin(*bearSSL, String("https://" + host + "/box/activate") +
                      "?key=" + key);

      client.collectHeaders(headerKeys, numberOfHeaders);
      int httpCode = client.GET();

      if(httpCode >= 200 && httpCode <= 299){
        serverAvailable = true;
        if(DEBUG){Serial.println("Successfully contacted server");}
      } else {
        serverAvailable = false;
        if(DEBUG){Serial.println("Server contact failure: " + String(httpCode));}
      }

      // Check activation headers:
      // If "code", display the activation code
      // If "user", we've been acivated and assigned to a user,
      //    so save that information.
      if(client.hasHeader("code") && code == ""){
        code = client.header("code");
        state = false;
      } else if(client.hasHeader("user")){
        user = client.header("user");
        state = false;
      } else if(client.hasHeader("reset")){
        resetBox();
      }

      client.end();
    }
  }
  delay(5);
}

void ICACHE_RAM_ATTR onTime() {
  httpCheck++;
  lidCheck++;
}

void downloadMessage(){
  if(DEBUG){Serial.println("Downloading message.");}
  if(SPIFFS.exists(imageName)){
    SPIFFS.remove(imageName);
  }
  File image = SPIFFS.open(imageName, "w");
  if(!image){
    //Image open failed!
    return;
  }
  int len = client.getSize();
  if(DEBUG){Serial.print("Download size: "); Serial.println(client.getSize());}
  WiFiClient* stream = client.getStreamPtr();
  while(client.connected() && (len > 0 || len == -1)){
    size_t size = stream->available();
    for(size_t i = 0; i < size; i++){
      image.write(stream->read());
      int c = 1;
      if(len > 0){
        len -= c;
      }
    }
    delay(1);
  }
  image.close();
  if(DEBUG){Serial.println("Download complete.");}
  uint32_t color = ring.Color(15, 15, 255);
  for(int i=0; i<ring.numPixels(); i++){
    //color = ring.Color(8, 8, 255);
    ring.setPixelColor(i,color);
  }
  ring.setBrightness(64);
  ring.show();
}

void displayWiFiLogin(){
  tft.fillScreen(ST77XX_BLACK);
  tft.setCursor(0, 50);
  tft.println("   Connect your phone to");
  tft.println("   the 'Messagebox' WiFi");
  tft.println("   network to set me up!");
}

void displayConnecting(){
  tft.fillScreen(ST77XX_BLACK);
  tft.setCursor(30, 50);
  tft.println("Connecting to WiFi");
}


void displayWiFiConnected(){
  tft.fillScreen(ST77XX_BLACK);
  tft.setCursor(10,60);
  tft.println("WiFi Network Connected!");
}

void displayActivationCode(){
  tft.fillScreen(ST77XX_BLACK);
  tft.setCursor(0,40);
  tft.println("       Activate me @");
  tft.println(host + "/register");
  tft.println("    in your browser.");
  tft.println("");
  tft.println("      Activation Code:");
  tft.println("         " + code);
}

void displayNoServer(){
  tft.fillScreen(ST77XX_BLACK);
  tft.setCursor(10,70);
  tft.println("Can't contact MessageBox");
  tft.setCursor(70,80);
  tft.println(":(");
}

void displayMessage(){
  File messageFile = SPIFFS.open(imageName, "r");
  if(DEBUG){Serial.print("File size: "); Serial.println(messageFile.size());}
  uint16_t pixel;
  for(int i = 0; i < HEIGHT; i++){
    for(int j = 0; j < WIDTH; j++){
      pixel = messageFile.read();
      pixel += messageFile.read() << 8;
      tft.drawPixel(j, i, pixel);
    }
  }
}

void drawHeart(int x, int y){
  tft.fillCircle(x+4, y+4, 4, 0xB882);
  tft.fillCircle(x+12, y+4, 4, 0xB882);
  tft.fillTriangle(x, y+4, x+16, y+4, x+8, y+16, 0xB882);
}



// Set time via NTP, as required for x.509 validation
void setClock() {
  configTime(3 * 3600, 0, "pool.ntp.org", "time.nist.gov");
  if(DEBUG){Serial.print("Waiting for NTP time sync: ");}
  time_t now = time(nullptr);
  while (now < 8 * 3600 * 2) {
    delay(500);
    if(DEBUG){Serial.print(".");}
    now = time(nullptr);
  }
  if(DEBUG){Serial.println("");}
  struct tm timeinfo;
  gmtime_r(&now, &timeinfo);
  if(DEBUG){
    Serial.print("Current time: ");
    Serial.print(asctime(&timeinfo));
  }
}
